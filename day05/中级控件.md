# 中级控件

本章介绍App开发常见的几类中级控件的用法，主要包括：如何定制几种简单的图形、如何使用几种选择按钮、如何高效地输入文本、如何利用对话框获取交互信息等，然后结合本章所学的知识，演示了一个实战项目“找回密码”的设计与实现。

## **图形****Drawable**

###### Drawable 类型表达了各种各样的图形，包括图片、色块、画板、背景等。 

###### 包含图片在内的图形文件放在res目录的各个drawable目录下，其中drawable目录一般保存描述性的XML文件，而图片文件一般放在具体分辨率的drawable目录下。 

###### 各视图的background属性、ImageView 和 ImageButton的src属性、TextView和Button四个方向的drawable***系列属性都可以引用图形文件。

包含图片在内的图形文件放在res目录的各个drawable目录下，其中drawable目录一般保存描述性的XML文件，而图片文件一般放在具体分辨率的drawable目录下。例如：

- drawable-ldpi里面存放低分辨率的图片（如240×320），现在基本没有这样的智能手机了。

- drawable-mdpi里面存放中等分辨率的图片（如320×480），这样的智能手机已经很少了。

- drawable-hdpi里面存放高分辨率的图片（如480×800），一般对应4英寸～4.5英寸的手机（但不绝对，同尺寸的手机有可能分辨率不同，手机分辨率就高不就低，因为分辨率低了屏幕会有模糊的感觉）。

- drawable-xhdpi里面存放加高分辨率的图片（如720×1280），一般对应5英寸～5.5英寸的手机。

- drawable-xxhdpi里面存放超高分辨率的图片（如1080×1920），一般对应6英寸～6.5英寸的手机。

- drawable-xxxhdpi里面存放超超高分辨率的图片（如1440×2560），一般对应7英寸以上的平板电脑。

基本上，分辨率每加大一级，宽度和高度就要增加二分之一或三分之一像素。如果各目录存在同名图片，Android就会根据手机的分辨率分别适配对应文件夹里的图片。在开发App时，为了兼容不同的手机屏幕，在各目录存放不同分辨率的图片，才能达到最合适的显示效果。

例如，在drawable-hdpi放了一张背景图片bg.png（分辨率为480×800），其他目录没放，使用分辨率为480×800的手机查看该App界

面没有问题，但是使用分辨率为720×1280的手机查看该App会发现背景图片有点模糊，原因是Android为了让bg.png适配高分辨率的屏幕，强行把bg.png拉伸到了720×1280，拉伸的后果是图片变模糊了。

在XML布局文件中引用图形文件可使用“@drawable/不含扩展名的文件名称”这种形式，如各视图的background属性、ImageView和ImageButton的src属性、TextView和Button四个方向的drawable***系列属性都可以引用图形文件。

## **形状图形**

###### Shape图形又称形状图形，它用来描述常见的几何形状，包括矩形、圆角矩形、圆形、椭圆等等。 

###### 形状图形的定义文件是以shape标签为根节点的XML描述文件，它支持四种类型的形状： 

- rectangle：矩形。默认值 

- oval：椭圆。此时corners节点会失效 

- line：直线。此时必须设置stroke节点，不然会报错 

- ring：圆环 

### **形状图形的规格定义**

###### 除了根节点shape标签，形状图形还拥有下列规格标签

- size（尺寸），它描述了形状图形的宽高尺寸。 

- stroke（描边），它描述了形状图形的描边规格。 

- corners（圆角），它描述了形状图形的圆角大小。 

- solid（填充），它描述了形状图形的填充色彩。 

- padding（间隔），它描述了形状图形与周围边界的间隔。 

- gradient（渐变），它描述了形状图形的颜色渐变

new > activity > DrawableShapeActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
   <View
       android:id="@+id/v_content"
       android:layout_width="match_parent"
       android:layout_height="200dp"
       android:layout_margin="10dp"/>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <Button
            android:id="@+id/btn_rect"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="圆角矩形背景"/>
        <Button
            android:id="@+id/btn_oval"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="椭圆背景"/>
    </LinearLayout>
</LinearLayout>
```

矩形圆角

new > Drawable Resource File > shape_rect_gold > shape

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- 指定了形状内部的填充颜色 -->
    <solid android:color="#ffdd66" />
    <!-- 指定了形状轮廓的粗细与颜色 -->
    <stroke android:width="1dp" android:color="#aaaaaa" />
    <!-- 指定了形状四个圆角的半径 -->
    <corners android:radius="10dp" />
</shape>
```

椭圆

new > Drawable Resource File > shape_oval_rose > shape

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <!-- 指定了形状内部的填充颜色 -->
    <solid android:color="#ffaaaa"/>
    <!-- 指定了形状轮廓的粗细与颜色 -->
    <stroke android:width="1dp" android:color="#aaaaaa" />
</shape>
```

```xml
public class DrawableShapeActivity extends AppCompatActivity implements View.OnClickListener {
    private View v_content;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_drawable_shape);
        findViewById(R.id.v_content);
        findViewById(R.id.btn_rect).setOnClickListener(this);
        findViewById(R.id.btn_oval).setOnClickListener(this);
        // 从布局文件中获取名为v_content的视图
        v_content = findViewById(R.id.v_content);
        // v_content的背景设置为圆角矩形
        v_content.setBackgroundResource(R.drawable.shape_rect_gold);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.btn_rect:
                v_content.setBackgroundResource(R.drawable.shape_rect_gold);
                break;
            case R.id.btn_oval:
                v_content.setBackgroundResource(R.drawable.shape_oval_rose);
                break;
        }
    }
}
```

## **九宫格图片**

###### 将某张图片设置成视图背景时，如果图片尺寸太小，则系统会自动拉伸图片使之填满背景。 

###### 可是一旦图片拉得过大，其画面容易变得模糊。

new > dir... > drawable-xhdpi > button_normal_orig.png 》Create 9-Patch file...

### **九宫格图片的四边涵义**

![image-20220921220436689](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921220436689.png)

- 界面上边的黑线指的是水平方向的拉伸区域。水平方向拉伸图片时，只有黑线区域内的图像会拉伸，黑线以外的图像保持原状，从而保证左右两侧的边框厚度不变。

- 界面左边的黑线指的是垂直方向的拉伸区域。垂直方向拉伸图片时，只有黑线区域内的图像会拉伸，黑线以外的图像保持原状，从而保证上下两侧的边框厚度不变

- 界面下边的黑线指的是该图片作为控件背景时，控件内部的文字左右边界只能放在黑线区域内。这里Horizontal Padding的效果就相当于android:paddingLeft与android:paddingRight。

- 界面右边的黑线指的是该图片作为控件背景时，控件内部的文字上下边界只能放在黑线区域内。这里Vertical Padding的效果就相当于android:paddingTop与android:paddingBottom。

如果点九图片被设置为视图背景，且该图片指定了Horizontal Padding和Vertical Padding，那么视图内部将一直与视图边缘保持固定间距，无论怎么调整XML文件和Java代码都无法缩小间隔，缘由是点九图片早已在水平和垂直方向都设置了padding。

new > activity > DrawableNineActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/button_normal_orig"
        android:text="普通图片背景"/>
    <! -- button_normal_orig.9.png => button_normal.png -->
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/button_normal"
        android:text="九宫格图片背景"/>
</LinearLayout>
```

```xml
values > themes.xml
<style name="Theme.MyApplication" parent="Theme.MaterialComponents.DayNight.DarkActionBar.Bridge">
```

## **状态列表图形** 

###### Button按钮的背景在正常情况下是凸起的，在按下时是凹陷的，从按下到弹起的过程，用户便能知道点击了这个按钮。 

### **状态类型的取值说明**

###### 状态列表图形不仅用于按钮控件，还可用于其他拥有多种状态的控件

![image-20220921222646145](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921222646145.png)

#### **按钮**

new > Drawable Resource File > btn_nine_selector> selector

copy > button_pressed.9.png

```xml
<selector xmlns:android="http://schemas.android.com/apk/res/android"> 
    <item android:state_pressed="true" android:drawable="@drawable/button_pressed" /> 
    <item android:drawable="@drawable/button_normal" /> 
</selector>
```

new > activity > DrawableStateActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="普通按钮"/>
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@drawable/btn_nine_selector"
        android:text="订制按钮"/>
</LinearLayout>
```

#### **复选框****CheckBox** 

###### CompoundButton类是抽象的复合按钮，由它派生而来的子类包括：复选框CheckBox、 单选按钮RadioButton以及开关按钮Switch。 

###### 下图描述了复合按钮的继承关系： 

![image-20220921224339270](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921224339270.png)

##### **CompoundButton****的基本用法** 

###### CompoundButton 在 XML 文件中主要使用下面两个属性。 

- checked：指定按钮的勾选状态，true表示勾选，false表示未勾选。默认未勾选。 

- button：指定左侧勾选图标的图形资源。如果不指定就使用系统的默认图标。 

###### CompoundButton 在 Java 代码中主要使用下列4种方法。 

- setChecked：设置按钮的勾选状态。 

- setButtonDrawable：设置左侧勾选图标的图形资源。 

- setOnCheckedChangeListener：设置勾选状态变化的监听器。 

- isChecked：判断按钮是否勾选。 

new > activity > CheckBoxActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <CheckBox
        android:id="@+id/ck_system"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="5dp"
        android:text="这是系统的CheckBox"
        android:textColor="@color/black"
        android:textSize="20sp" />
    <CheckBox
        android:id="@+id/ck_custom"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:button="@drawable/checkbox_selector"
        android:checked="true"
        android:padding="5dp"
        android:text="自定义图标CheckBox"
        android:textColor="@color/black"
        android:textSize="20sp" />
</LinearLayout>
```

new > Drawable Resource File > checkbox_selector> selector

copy > ....png

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_checked="true" android:drawable="@drawable/check_choose" />
    <item android:drawable="@drawable/check_unchoose" />
</selector>
```

```java
public class CheckBoxActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_check_box);
        // 从布局文件中获取名叫ck_system的复选框
        CheckBox ck_system = findViewById(R.id.ck_system);
        // 从布局文件中获取名叫ck_custom的复选框
        CheckBox ck_custom = findViewById(R.id.ck_custom);
        // 给ck_system设置勾选监听器，一旦用户点击复选框，就触发监听器的onCheckedChanged方 法
        ck_system.setOnCheckedChangeListener(this);
        // 给ck_custom设置勾选监听器，一旦用户点击复选框，就触发监听器的onCheckedChanged方 法
        ck_custom.setOnCheckedChangeListener(this);
    }
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        String desc = String.format("您%s了这个CheckBox", isChecked ? "勾选" : "取 消勾选");
        buttonView.setText(desc);
    }
}
```

#### **开关按钮****Switch**

###### Switch 是开关按钮，它在选中与取消选中时可展现的界面元素比复选框丰富。 

###### Switch 控件新添加的XML属性说明如下：

- textOn：设置右侧开启时的文本。 

- textOff：设置左侧关闭时的文本。 

- track：设置开关轨道的背景。 

- thumb：设置开关标识的图标。 

new >  activity > SwitchActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="start"
            android:text="Switch开关："
            android:textColor="@color/black"
            android:textSize="20sp" />
        <Switch
            android:id="@+id/sw_status"
            android:layout_width="80dp"
            android:layout_height="30dp"
            android:layout_gravity="end"/>
    </LinearLayout>
    <TextView
        android:id="@+id/tv_result"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="start"
        android:text="Switch开关状态"
        android:textColor="@color/black"
        android:textSize="20sp" />
</LinearLayout>
```

```xml
public class SwitchActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener {
    private TextView tv_result;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_switch);

        Switch sw_status = findViewById(R.id.sw_status);
        tv_result = findViewById(R.id.tv_result);
        sw_status.setOnCheckedChangeListener(this);

    }
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        String desc = String.format("Switch按钮的状态是%s", isChecked ? "开启" : "关闭");
        tv_result.setText(desc);
    }
}
```

#### **仿****iOS****的开关按钮**

###### 借助状态列表图形StateListDrawable，分别定义已选中时候的“开”图形，以及未选中时候的“关”图形。 

###### 然后把CheckBox控件的background属性设置为该状态图形

![image-20220921231637273](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921231637273.png)

```xml
<CheckBox 
          android:id="@+id/ck_status" 
          android:layout_width="60dp" 
          android:layout_height="30dp" 
          android:background="@drawable/switch_selector" 
          android:button="@null" />
```

new > Drawable Resource File > switch_selector> selector

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_checked="true" android:drawable="@drawable/switch_on"/> 
    <item android:drawable="@drawable/switch_off"/>
</selector>
```

```xml
public class SwitchActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener {
    private TextView tv_result;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_switch);

        Switch sw_status = findViewById(R.id.sw_status);
        CheckBox ck_status = findViewById(R.id.ck_status);
        tv_result = findViewById(R.id.tv_result);

        sw_status.setOnCheckedChangeListener(this);
        ck_status.setOnCheckedChangeListener(this);
    }
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        String desc = String.format("Switch按钮的状态是%s", isChecked ? "开启" : "关闭");
        tv_result.setText(desc);
    }
}
```

#### **单选按钮****RadioButton**

###### 单选按钮要在一组按钮中选择其中一项，并且不能多选，这要求有个容器确定这组按钮的范围，这个容器便是单选组RadioGroup。 

###### RadioGroup实质上是个布局，同一组RadioButton都要放在同一个RadioGroup节点下。除了RadioButton，也允许放置其他控件

##### **单选组的用法**

###### 判断选中了哪个单选按钮，通常不是监听某个单选按钮，而是监听单选组的选中事件。 

###### 下面是RadioGroup常用的3个方法： 

- check：选中指定资源编号的单选按钮。 

- getCheckedRadioButtonId：获取选中状态单选按钮的资源编号。 

- setOnCheckedChangeListener：设置单选按钮勾选变化的监听器。

new >  activity > RadioActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="start"
        android:text="请选择你的性别"
        android:textColor="@color/black"
        android:textSize="20sp" />
    <RadioGroup
        android:id="@+id/rg_sex"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal" >
        <RadioButton
            android:id="@+id/rb_male"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:checked="false"
            android:text="男"
            android:textColor="@color/black"
            android:textSize="17sp" />
        <RadioButton
            android:id="@+id/rb_female"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:checked="false"
            android:text="女"
            android:textColor="@color/black"
            android:textSize="17sp" />
    </RadioGroup>
    <TextView
        android:id="@+id/tv_result"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="start"
        android:text="选中的结果"
        android:textColor="@color/black"
        android:textSize="20sp" />

</LinearLayout>
```

```java
public class RadioActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener {
    private TextView tv_result; // 声明一个文本视图对象
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_radio);
        // 从布局文件中获取名叫tv_sex的文本视图
        tv_result = findViewById(R.id.tv_result);
        // 从布局文件中获取名叫rg_sex的单选组
        RadioGroup rg_sex = findViewById(R.id.rg_sex);
        // 设置单选监听器，一旦点击组内的单选按钮，就触发监听器的onCheckedChanged方法
        rg_sex.setOnCheckedChangeListener(this);
    }

    @Override
    public void onCheckedChanged(RadioGroup group, int checkedId) {
        if (checkedId == R.id.rb_male) {
            tv_result.setText("哇哦，你是个帅气的男孩");
        } else if (checkedId == R.id.rb_female) {
            tv_result.setText("哇哦，你是个漂亮的女孩");
        }
    }
}
```

#### **编辑框****EditText**

###### EditText 是文本编辑框，用户可在此输入文本等信息。 

###### EditText 的常用属性说明如下：

- inputType：指定输入的文本类型。若同时使用多种文本类型，则可使用竖线“

”把多种文本类 型拼接起来。 

- maxLength：指定文本允许输入的最大长度。 

- hint：指定提示文本的内容。 

- textColorHint：指定提示文本的颜色

##### **输入类型的取值说明**

![image-20220921233440812](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921233440812.png)

new >  activity > EditTextActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:text="下面是登录信息"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入用户名"
        android:inputType="text"
        android:maxLength="10"
        android:textColor="@color/black"
        android:textSize="17sp" />

    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入密码"
        android:inputType="textPassword"
        android:maxLength="8"
        android:textColor="@color/black"
        android:textSize="17sp" />
</LinearLayout>
```

##### 自定义边框和样式

new > Drawable Resource File > shape_edit_normal> shape

new > Drawable Resource File > shape_edit_focus> shape

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- 指定了形状内部的填充颜色 -->
    <solid android:color="#ffffff" />
    <!-- 指定了形状轮廓的粗细与颜色 -->
    <!--  shape_edit_normal-->
    <stroke
        android:width="1dp"
        android:color="#aaaaaa" />
   <!--  shape_edit_focus-->
    <stroke
        android:width="1dp"
        android:color="#0000ff" />
    <!-- 指定了形状四个圆角的半径 -->
    <corners android:radius="5dp" />
    <!-- 指定了形状四个方向的间距 -->
    <padding
        android:bottom="2dp"
        android:left="2dp"
        android:right="2dp"
        android:top="2dp" />
</shape>
```

new > Drawable Resource File > edit_selector> selector

```xml
<TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:text="自定义样式"
        android:textColor="@color/black"
        android:textSize="17sp" />

<EditText
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:inputType="text"
          android:hint="我的边框不见了"
          android:background="@null"
          android:maxLength="10"
          android:textColor="@color/black"
          android:textSize="17sp" />

<EditText
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:hint="我的边框是圆角"
          android:background="@drawable/edit_selector"
          android:inputType="textPassword"
          android:maxLength="8"
          android:textColor="@color/black"
          android:textSize="17sp" />
```

#### **焦点变更监听器**

###### 编辑框点击两次后才会触发点击事件，因为第一次点击只触发焦点变更事件，第二次点击才触发点击事件。 

###### 若要判断是否切换编辑框输入，应当监听焦点变更事件，而非监听点击事件。 

###### 调用编辑框对象的setOnFocusChangeListener方法，即可在光标切换之时（获得光标和失去光标）触发焦点变更事件。

手机号码未输满11位，就点击密码框，此时校验不通过，一边弹出提示文字，一边把焦点拉回手机框。 

![image-20220921235430402](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921235430402.png)

new > activity > EditFocusActivity

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="5dp">
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:text="下面是登录信息"
        android:textColor="@color/black"
        android:textSize="17sp" />
    <EditText
        android:id="@+id/et_phone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入11位手机号"
        android:background="@drawable/edit_selector"
        android:inputType="number"
        android:maxLength="11"
        android:textColor="@color/black"
        android:textSize="17sp" />
    <EditText
        android:id="@+id/et_pwd"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入密码"
        android:background="@drawable/edit_selector"
        android:inputType="numberPassword"
        android:maxLength="16"
        android:textColor="@color/black"
        android:textSize="17sp" />
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="登录"
        android:textColor="@color/black"
        android:textSize="17sp" />
</LinearLayout>
```

```java
public class EditFocusActivity extends AppCompatActivity implements View.OnFocusChangeListener {
    private EditText et_phone;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_edit_focus);
        // 从布局文件中获取名为et_password的编辑框
        et_phone = findViewById(R.id.et_phone);
        EditText et_password = findViewById(R.id.et_pwd);
        // 给编辑框注册一个焦点变化监听器，一旦焦点发生变化，就触发监听器的onFocusChange方法
        et_password.setOnFocusChangeListener(this);
    }

    @Override
    public void onFocusChange(View v, boolean hasFocus) {
        // 判断密码编辑框是否获得焦点。hasFocus为true表示获得焦点，为false表示失去焦点
        if (v.getId() == R.id.et_pwd && hasFocus) {
            String phone = et_phone.getText().toString();
            if (TextUtils.isEmpty(phone) || phone.length() < 11) {
                // 手机号码不足11位
                // 手机号码编辑框请求焦点，也就是把光标移回手机号码编辑框
                et_phone.requestFocus();
                Toast.makeText(this, "请输入11位手机号码", Toast.LENGTH_SHORT).show();
            }
        }
    }
}
```

#### **文本变化监听器** 

###### 判断手机号输入满11位后自动关闭软键盘，或者密码输入满6位后自动关闭软键盘，此时要注册文本变化监听器。 

###### 达到指定位数便自动关闭键盘的功能，可以再分解为两个独立的功能点 

- 如何关闭软键盘； 

- 如何判断已输入的文字达到指定位数； 

**文本变化监听器的用法**

###### 调用编辑框对象的 addTextChangedListener 方法即可注册文本监听器

###### 文本监听器的接口名称为 TextWatcher，该接口提供了3个监控方法，具体说明如下

- beforeTextChanged：在文本改变之前触发。 
- onTextChanged：在文本改变过程中触发。 

- afterTextChanged：在文本改变之后触发。 

![image-20220921235704634](C:\Users\15596\AppData\Roaming\Typora\typora-user-images\image-20220921235704634.png)